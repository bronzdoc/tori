require "torrent"
require "message"
require "tracker_manager"

module Tori
  class Client

    def initialize(torrent)
      @torrent = torrent
      @active_peers = []
      @peer_id = Digest::SHA1.digest("#{Process.pid}#{DateTime.now}")

      @state = {
        am_choking:      1, # this client is choking the peer
        am_interested:   0, # this client is interested in the peer
        peer_choking:    1, # peer is choking this client
        peer_interested: 0  # peer is interested in this client
      }

      @request_params = {
        # URL encoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
        # Note that the value will be a bencoded dictionary,
        info_hash:  @torrent.info_hash,

        # URL encoded 20-byte string used as a unique ID for the client,
        # generated by the client at startup. This is allowed to be any value, and may be binary data.
        peer_id:    @peer_id,

        # Ports reserved for BitTorrent are typically 6881-6889.
        port:       6885,

        # The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        # this should be the total number of bytes uploaded.
        uploaded:   0,

        # The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        # this should be the total number of bytes downloaded.
        downloaded: 0,

        # The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
        left:      @torrent.length,

        # Indicates that the client accepts a compact response (1 is yes, 0 is no).
        compact:    1,

        # Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
        no_peer_id: 0,

        # event: If specified, must be one of STARTED, COMPLETED, STOPPED
        # If not specified, then this request is one performed at regular intervals.
        # started: The first request to the tracker must include the event key with this value.
        # stopped: Must be sent to the tracker if the client is shutting down gracefully.
        # completed: Must be sent to the tracker when the download completes. However,
        # must not be sent if the download was already 100% complete when the client started.
        # Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event
        event:      "started"
      }
    end

    def run!
      puts "Connecting to peers!"
      connect_to_peers
      @active_peers.each do |peer|
        send_message(Message.new({
          length: 0x0001,
          id:     2
        }), peer)
      end
    end

    private
    def connect_to_peers
      peer_list = get_peer_list
      peer_list.each do |peers|
        peers.each do |peer|
          handshake_response = peer.connect(handshake)
          unless handshake_response.nil?
            if handshake_response[:info_hash] == @torrent.info_hash
              puts "Getting into active_peers: #{peer.object_id}"
              @active_peers << peer
            else
              disconnect peer
            end
          end
          # TODO Remove this, only for testing
          break if @active_peers.size > 5
        end
      end
    end

    def handshake
      pstrlen = [19].pack("C*")
      pstr = "BitTorrent protocol"
      reserved = [0,0].pack("N*")
      info_hash = @torrent.info_hash
      peer_id = @peer_id

      "#{pstrlen}#{pstr}#{reserved}#{info_hash}#{peer_id}"
    end

    def disconnect(peer)
      peer.close_connection
    end

    def get_peer_list
      peer_list = []
      @torrent.trackers.each do |tracker|
        peers = tracker.request_peers(@request_params)
        peer_list << peers unless peers.nil?
      end
      peer_list
    end

    def send_message(message, peer)
      #@active_peers.each do

      res = peer.send(message)
      #case res.type
      #when :keep_alive
      #peer.send Message.new
      #when :choke
      #when :unchoke
      #when :interested
      #when :not_interested
      #when :have
      #end

      #response = {
      #    pstr:      peer.connection.read(1),
      #    pstrlen:   peer.connection.read(19),
      #    reserved:  peer.connection.read(8),
      #    info_hash: peer.connection.read(20).unpack("M*")[0],
      #    peer_id:   peer.connection.read(20).unpack("M*")[0]
      #}
      #p response
      #end
      puts "esto es res: #{res}"
    end
  end
end
