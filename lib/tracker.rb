require "date"
require "net/http"
require "socket"
require "bencode"
require "digest"
require "ipaddr"
require "peer"

module Tori
  class Tracker
    attr_reader :options, :peer_id, :peers, :response, :tracker

    def initialize(torrent)
      @peer_id = Digest::SHA1.digest "#{Process.pid}#{DateTime.now}"
      @torrent = torrent
      @tracker = URI @torrent.announce
      @options = {
        # URL encoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
        # Note that the value will be a bencoded dictionary,
        info_hash:  @torrent.info_hash,

        # URL encoded 20-byte string used as a unique ID for the client,
        # generated by the client at startup. This is allowed to be any value, and may be binary data.
        peer_id:    @peer_id,

        # Ports reserved for BitTorrent are typically 6881-6889.
        port:       6885,

        # The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        # this should be the total number of bytes uploaded.
        uploaded:   0,

        # The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        # this should be the total number of bytes downloaded.
        downloaded: 0,

        # The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
        left:      @torrent.length,

        # Indicates that the client accepts a compact response (1 is yes, 0 is no).
        compact:    1,

        # Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
        no_peer_id: 0,

        # event: If specified, must be one of STARTED, COMPLETED, STOPPED
        # If not specified, then this request is one performed at regular intervals.
        # started: The first request to the tracker must include the event key with this value.
        # stopped: Must be sent to the tracker if the client is shutting down gracefully.
        # completed: Must be sent to the tracker when the download completes. However,
        # must not be sent if the download was already 100% complete when the client started.
        # Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event
        event:      "started"
      }
    end

    def peers
      # Divide byte string into 6 byte chunks
      peer_ips_hex = []
      @peers.scan(/.{6}/).each { |chunk| peer_ips_hex << chunk.unpack("a4n") }

      # Parse ip and port and store it
      # NOTE the ip is the first four bytes, the remaining 2 combined is the port
      @peers = []
      peer_ips_hex.each do |hex_ip, port|
        @peers << Peer.new(IPAddr.new_ntoh(hex_ip).to_s, port)
      end
      @peers
    end
  end
end
