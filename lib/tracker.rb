require "date"
require "net/http"
require "socket"
require "bencode"
require "digest"
require "ipaddr"
require "peer"

module Tori
  class Tracker
    attr_reader :peers

    def initialize(announce_url)
      @host = URI(announce_url).host
      @port = URI(announce_url).port
    end

    #def initialize(torrent)
      #@peer_id = Digest::SHA1.digest "#{Process.pid}#{DateTime.now}"
      #@torrent = torrent
      #@host = URI(@torrent.announce).host
      #@port = URI(@torrent.announce).port
      #@options = {
      #  # URL encoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
      #  # Note that the value will be a bencoded dictionary,
      #  info_hash:  @torrent.info_hash,

      #  # URL encoded 20-byte string used as a unique ID for the client,
      #  # generated by the client at startup. This is allowed to be any value, and may be binary data.
      #  peer_id:    @peer_id,

      #  # Ports reserved for BitTorrent are typically 6881-6889.
      #  port:       6885,

      #  # The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
      #  # this should be the total number of bytes uploaded.
      #  uploaded:   0,

      #  # The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
      #  # this should be the total number of bytes downloaded.
      #  downloaded: 0,

      #  # The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
      #  left:      @torrent.length,

      #  # Indicates that the client accepts a compact response (1 is yes, 0 is no).
      #  compact:    1,

      #  # Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
      #  no_peer_id: 0,

      #  # event: If specified, must be one of STARTED, COMPLETED, STOPPED
      #  # If not specified, then this request is one performed at regular intervals.
      #  # started: The first request to the tracker must include the event key with this value.
      #  # stopped: Must be sent to the tracker if the client is shutting down gracefully.
      #  # completed: Must be sent to the tracker when the download completes. However,
      #  # must not be sent if the download was already 100% complete when the client started.
      #  # Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event
      #  event:      "started"
      #}
    #end

    def request_peers(request_params)
      []
    end

    protected
    def parse_peers(peers)
      # Divide byte string into 6 byte chunks
      peer_ips_hex = []
      peers.scan(/.{6}/).each { |chunk| peer_ips_hex << chunk.unpack("a4n") }

      # Parse ip and port and store it
      # NOTE the ip is the first four bytes, the remaining 2 combined is the port
      peers = []
      peer_ips_hex.each do |hex_ip, port|
        peers << Peer.new(IPAddr.new_ntoh(hex_ip).to_s, port)
      end
      peers
    end

  end
end
