require "net/http"
require "socket"
require "date"
require "bencode"
require "digest"
require "ipaddr"
require "thread"
require "peer"

module Tori
  class Torrent

    attr_reader :metadata, :announce, :info_hash, :peer_id, :peers

    def initialize(torrent_file=nil)
      raise Tori::TorrentError if torrent_file.nil?
      bencoded_stream = File.open(File.expand_path(torrent_file)).read

      @metadata = parse bencoded_stream
      @announce = @metadata["announce"]
      @info_hash = Digest::SHA1.digest(@metadata["info"].bencode)
      @peer_id = Digest::SHA1.digest("#{Process.pid}#{DateTime.now}")
      @peers = get_peers
    end

    private
    def get_peers
      tracker_response = request_tracker
      peers = tracker_response["peers"]

      # Divide byte string into 6 byte chunks
      peer_ips_hex = []
      peers.scan(/.{6}/).each { |chunk| peer_ips_hex << chunk.unpack("a4n") }

      # Parse ip and port and store it
      # NOTE the ip is the first four bytes, the reminding 2 combined is the port
      peer_ips = []
      peer_ips_hex.each do |hex_ip, port|
        peer_ips << Peer.new(IPAddr.new_ntoh(hex_ip).to_s, port)
      end

      peer_ips
    end

    def request_tracker(&block)
      params={
        # URL encoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
        # Note that the value will be a bencoded dictionary,
        info_hash:  @info_hash,

        # URL encoded 20-byte string used as a unique ID for the client,
        # generated by the client at startup. This is allowed to be any value, and may be binary data.
        peer_id:    @peer_id,

        # Ports reserved for BitTorrent are typically 6881-6889.
        port:       6885,

        # The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        # this should be the total number of bytes uploaded.
        uploaded:   0,

        # The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        # this should be the total number of bytes downloaded.
        downloaded: 0,

        # The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
        left:      length,

        # Indicates that the client accepts a compact response (1 is yes, 0 is no).
        compact:    1,

        # Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
        no_peer_id: 0,

        # event: If specified, must be one of started, completed, stopped
        # If not specified, then this request is one performed at regular intervals.
        # started: The first request to the tracker must include the event key with this value.
        # stopped: Must be sent to the tracker if the client is shutting down gracefully.
        # completed: Must be sent to the tracker when the download completes. However,
        # must not be sent if the download was already 100% complete when the client started.
        # Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event
        event:      "started"
      }

      # Edit params when needed
      block.call params if block_given?

      tracker = URI @announce

      response =
        if tracker.scheme == "udp"
          udp_socket = UDPSocket.new

          ## Packet to request tracker for a connection id
          # Offset   | Size               | Name           | Value
          # -----------------------------------------------------------------------
          # 0        | 8 (64 bit integer) | connection id  | for this request, the initial value 0x41727101980
          # 8        | 4 (32-bit integer) | action  0 for  | connection request
          # 12       | 4 (32-bit integer) | transaction id | a random number created by client
          first_32_bit_conn_id =  0x41727101980 >> 32
          second_32_bit_conn_id = 0x41727101980 & 0xffffffff

          #connection_id = 0x41727101980
          #buffer = [connection_id >> 32, connection_id & 0xffffffff, 0, 16].pack "N*"

          buffer = [first_32_bit_conn_id, second_32_bit_conn_id, 0, 16].pack "N*"
          c0, c1, action, client_transaction_id = buffer.unpack "N*"

          udp_socket.send buffer, 0, tracker.host, tracker.port
          res = udp_socket.recvfrom(5000)

          ## Tracker response
          # Offset |  Size               | Name            | Value
          #------------------------------------------------------------------------
          # 0      |  4 (32-bit integer) | action          | 0 for connect response
          # 4      |  4 (32-bit integer) | transaction id  | same like request's transaction id.
          # 8      |  8 (64 bit integer) | connection id   | a connection id that must be acceptable for at least 2 minutes from source
          #res_action, res_transaction_id, res_connection_id = res[0].unpack "N*"
          res_action, res_transaction_id, res_connection_id = res[0].unpack "NNQ"

          #####  buildAnnounceRequest #####
          #connection id:  1417659898586446182
          #transaction id: -2025418972
          #info hash:      [43, 111, 16, -4, 40, -83, -128, -83, -16, -78, -66, -114, -9, 96, 119, -122, 40, 39, 42, -19]
          #peer id:        [45, 84, 79, 48, 48, 52, 50, 45, 52, 54, 53, 99, 54, 48, 52, 51, 56, 54, 57, 49]
          #downloaded:     0
          #uploaded        0
          #left:           1130449
          #event:          STARTED
          #adress:         /127.0.1.1
          #key:            0
          #num want:       50
          #port:           49152
          #Setting announce interval to 1656s per tracker request.

          client_announce = [
            res_connection_id,
            1,
            client_transaction_id,
            @info_hash,
            @peer_id,
            0,
            1,

            params[:left],

            0,
            0,

            0,
            0,

            0,
            50,
            params[:port]
          ].pack("Q<NNA20A20NNQ<NNNNNNS")
          #.pack("SNNNNNQ<NNNA20A20NNQ<")
          p client_announce.unpack("Q<NNA20A20NNQ<NNNNNNS")

          #client_announce = [
          #  params[:port],
          #  50,
          #  0,
          #  "127.0.1.1",
          #  params[:event],
          #  params[:left],
          #  0,
          #  0,
          #  @peer_id,
          #  @info_hash,
          #  res_transaction_id,
          #  1,
          #  res_connection_id & 0xffffffff,
          #  res_connection_id >> 32
          #].pack("SNNBBQQQBBN*")

          p client_announce.size

          # We need to check if the transaction id match with the transaction_id of the response
          # TODO request announce
          if res_transaction_id == client_transaction_id
            udp_socket.send client_announce, 0, tracker.host, tracker.port
            res = udp_socket.recvfrom(5000)
            p "#{res[0].unpack("N*")} #{res[1]}"
          end

          # If a response is not received after 15 * 2 ^ n seconds, the client should retransmit the request,
          # where n starts at 0 and is increased up to 8 (3840 seconds) after every retransmission.
          # Note that it is necessary to rerequest a connection ID when it has expired.

          #0.upto 8 do |n|
          #  p tracker.host
          #  Thread.new do
          #    udp_socket.send buffer, 0, tracker.host, tracker.port
          #    if restest = udp_socket.recvfrom(5000)
          #      p restest
          #    end
          #  end
          #  sleep 15 * (2**n)
          #end
        else
          tracker.query = URI.encode_www_form(params)
          res = Net::HTTP.get_response(tracker)
          BEncode::Parser.new(res.body).parse! #tracker response
        end
      response
    end

    def length
      length = 0
      info = @metadata["info"]

      if info.has_key? "length"
        length = info["length"]
      else
        info["files"].each {|file| length += file["length"]}
      end

      length
    end

    def parse(stream)
      BEncode::Parser.new(stream).parse!
    end
  end
end
