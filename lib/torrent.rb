require "net/http"
require "socket"
require "date"
require "bencode"
require "digest"
require "ipaddr"
require "thread"
require "peer"

module Tori
  class Torrent
    attr_reader :metadata, :announce, :info_hash, :peer_id, :peers

    def initialize(torrent_file=nil)
      raise Tori::TorrentError if torrent_file.nil?
      bencoded_stream = File.open(File.expand_path(torrent_file)).read

      @metadata = parse bencoded_stream
      @announce = @metadata["announce"]
      @info_hash = Digest::SHA1.digest(@metadata["info"].bencode)
      @peer_id = Digest::SHA1.digest("#{Process.pid}#{DateTime.now}")
      @peers = get_peers
    end

    private
    def get_peers
      tracker_response = request_tracker
      peers = tracker_response["peers"]

      # Divide byte string into 6 byte chunks
      peer_ips_hex = []
      peers.scan(/.{6}/).each { |chunk| peer_ips_hex << chunk.unpack("a4n") }

      # Parse ip and port and store it
      # NOTE the ip is the first four bytes, the reminding 2 combined is the port
      peer_ips = []
      peer_ips_hex.each do |hex_ip, port|
        peer_ips << Peer.new(IPAddr.new_ntoh(hex_ip).to_s, port)
      end

      peer_ips
    end

    def request_tracker(&block)
      params={
        # URL encoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
        # Note that the value will be a bencoded dictionary,
        info_hash:  @info_hash,

        # URL encoded 20-byte string used as a unique ID for the client,
        # generated by the client at startup. This is allowed to be any value, and may be binary data.
        peer_id:    @peer_id,

        # Ports reserved for BitTorrent are typically 6881-6889.
        port:       6885,

        # The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        # this should be the total number of bytes uploaded.
        uploaded:   0,

        # The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
        # this should be the total number of bytes downloaded.
        downloaded: 0,

        # The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
        left:      length,

        # Indicates that the client accepts a compact response (1 is yes, 0 is no).
        compact:    1,

        # Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
        no_peer_id: 0,

        # event: If specified, must be one of started, completed, stopped
        # If not specified, then this request is one performed at regular intervals.
        # started: The first request to the tracker must include the event key with this value.
        # stopped: Must be sent to the tracker if the client is shutting down gracefully.
        # completed: Must be sent to the tracker when the download completes. However,
        # must not be sent if the download was already 100% complete when the client started.
        # Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event
        event:      "started"
      }

      # Edit params when needed
      block.call params if block_given?

      tracker = URI @announce

      response =
        if tracker.scheme == "udp"
          udp_socket = UDPSocket.new

          ## Request Tracker for
          # Offset   | Size               | Name           | Value
          # -----------------------------------------------------------------------
          # 0        | 8 (64 bit integer) | connection id  | for this request, the initial value 0x41727101980
          # 8        | 4 (32-bit integer) | action  0 for  | connection request
          # 12       | 4 (32-bit integer) | transaction id | a random number created by client
          connection_id = 0x41727101980
          buffer = [connection_id >> 32, connection_id & 0xffffffff, 0, 16].pack('N*')

          #c0, c1, action, client_transaction_id = buffer.unpack "N*"

          udp_socket.send buffer, 0, tracker.host, tracker.port
          res = udp_socket.recvfrom(5000)

          ## Tracker response
          # Offset |  Size               | Name            | Value
          #------------------------------------------------------------------------
          # 0      |  4 (32-bit integer) | action          | 0 for connect response
          # 4      |  4 (32-bit integer) | transaction id  | same like request's transaction id.
          # 8      |  8 (64 bit integer) | connection id   | a connection id that must be acceptable for at least 2 minutes from source
          res_action, res_transaction_id, c1, c0 = res[0].unpack "N*"

          # We need to check if the transaction id match with the transaction_id of the response
          if res_transaction_id == client_transaction_id
          end

          # If a response is not received after 15 * 2 ^ n seconds, the client should retransmit the request,
          # where n starts at 0 and is increased up to 8 (3840 seconds) after every retransmission.
          # Note that it is necessary to rerequest a connection ID when it has expired.

          #0.upto 8 do |n|
          #  p tracker.host
          #  Thread.new do
          #    udp_socket.send buffer, 0, tracker.host, tracker.port
          #    if restest = udp_socket.recvfrom(5000)
          #      p restest
          #    end
          #  end
          #  sleep 15 * (2**n)
          #end
        else
          tracker.query = URI.encode_www_form(params)
          res = Net::HTTP.get_response(tracker)
          BEncode::Parser.new(res.body).parse! #tracker response
        end
      response
    end

    def length
      length = 0
      info = @metadata["info"]
      if info.has_key? "length"
        length = info["length"]
      else
        info["files"].each {|file| length += file["length"]}
      end
      length
    end

    def parse(stream)
      BEncode::Parser.new(stream).parse!
    end
  end
end
